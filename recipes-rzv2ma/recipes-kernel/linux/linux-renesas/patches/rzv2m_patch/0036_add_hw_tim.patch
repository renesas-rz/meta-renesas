From fad1598d55780701a4a033e7a7556362e36d2b6d Mon Sep 17 00:00:00 2001
From: Khai Nguyen <khai.nguyen.wx@renesas.com>
Date: Mon, 28 Feb 2022 13:51:37 +0700
Subject: [PATCH] add_hw_tim

Signed-off-by: Khai Nguyen <khai.nguyen.wx@renesas.com>
---
 .../dts/renesas/r9a09g011gbg-evaluation-board.dts  |  63 +++
 arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi      | 292 ++++++++++++-
 arch/arm64/configs/defconfig                       |   1 +
 drivers/Kconfig                                    |   2 +
 drivers/Makefile                                   |   1 +
 drivers/hw_tim/Kconfig                             |   8 +
 drivers/hw_tim/Makefile                            |   3 +
 drivers/hw_tim/tim_rzv2m.c                         | 452 +++++++++++++++++++++
 include/linux/tim_rzv2m.h                          |  54 +++
 9 files changed, 875 insertions(+), 1 deletion(-)
 create mode 100644 drivers/hw_tim/Kconfig
 create mode 100644 drivers/hw_tim/Makefile
 create mode 100644 drivers/hw_tim/tim_rzv2m.c
 create mode 100644 include/linux/tim_rzv2m.h

diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
index 644dcb1..4b0ab3c 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg-evaluation-board.dts
@@ -206,3 +206,66 @@
     status = "okay";
 };
 
+&tim16 {
+    status = "okay";
+};
+
+&tim17 {
+    status = "okay";
+};
+
+&tim18 {
+    status = "okay";
+};
+
+&tim19 {
+    status = "okay";
+};
+
+&tim20 {
+    status = "okay";
+};
+
+&tim21 {
+    status = "okay";
+};
+
+&tim22 {
+    status = "okay";
+};
+
+&tim23 {
+    status = "okay";
+};
+&tim24 {
+    status = "okay";
+};
+
+&tim25 {
+    status = "okay";
+};
+
+&tim26 {
+    status = "okay";
+};
+
+&tim27 {
+    status = "okay";
+};
+
+&tim28 {
+    status = "okay";
+};
+
+&tim29 {
+    status = "okay";
+};
+
+&tim30 {
+    status = "okay";
+};
+
+
+&tim31 {
+    status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
index 509431d..4778648 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g011gbg.dtsi
@@ -105,7 +105,11 @@
         compatible = "fixed-clock";
         clock-frequency = <48000000>;
     };
-
+    timclk: timclk@2M {
+        #clock-cells = <0>;
+        compatible = "fixed-clock";
+        clock-frequency = <2000000>;
+    };
     timer {
         compatible = "arm,armv8-timer";
         interrupts-extended = <&gic GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
@@ -327,6 +331,290 @@
             };
         };
 
+        tim0: timer@a4000000 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000000 0 0x80>;
+            interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim1: timer@a4000080 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000080 0 0x80>;
+            interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim2: timer@a4000100 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000100 0 0x80>;
+            interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim3: timer@a4000180 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000180 0 0x80>;
+            interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim4: timer@a4000200 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000200 0 0x80>;
+            interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim5: timer@a4000280 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000280 0 0x80>;
+            interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim6: timer@a4000300 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000300 0 0x80>;
+            interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim7: timer@a4000380 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000380 0 0x80>;
+            interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim8: timer@a4000400 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000400 0 0x80>;
+            interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim9: timer@a4000480 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000480 0 0x80>;
+            interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim10: timer@a4000500 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000500 0 0x80>;
+            interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim11: timer@a4000580 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000580 0 0x80>;
+            interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim12: timer@a4000600 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000600 0 0x80>;
+            interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim13: timer@a4000680 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000680 0 0x80>;
+            interrupts = <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim14: timer@a4000700 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000700 0 0x80>;
+            interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim15: timer@a4000780 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000780 0 0x80>;
+            interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+        tim16: timer@a4000800 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000800 0 0x80>;
+            interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+        tim17: timer@a4000880 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000880 0 0x80>;
+            interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim18: timer@a4000900 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000900 0 0x80>;
+            interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim19: timer@a4000980 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000980 0 0x80>;
+            interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim20: timer@a4000a00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000a00 0 0x80>;
+            interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim21: timer@a4000a80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000a80 0 0x80>;
+            interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim22: timer@a4000b00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000b00 0 0x80>;
+            interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+        tim23: timer@a4000b80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000b80 0 0x80>;
+            interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+        tim24: timer@a4000c00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000c00 0 0x80>;
+            interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+        tim25: timer@a4000c80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000c80 0 0x80>;
+            interrupts = <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim26: timer@a4000d00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000d00 0 0x80>;
+            interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim27: timer@a4000d80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000d80 0 0x80>;
+            interrupts = <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim28: timer@a4000e00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000e00 0 0x80>;
+            interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim29: timer@a4000e80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000e80 0 0x80>;
+            interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+
+        tim30: timer@a4000f00 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000f00 0 0x80>;
+            interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
+        tim31: timer@a4000f80 {
+            compatible =  "renesas,tim-rzv2m";
+            reg = <0 0xa4000f80 0 0x80>;
+            interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+            clocks = <&timclk>;
+            clock-names = "timclk";
+            status = "disabled";
+        };
+
         pwm0: pwm@a4010000 {
             compatible = "renesas,pwm-r8arzv2m-rzv2m", "renesas,pwm-v2m";
             reg = <0 0xa4010000 0 0x80>;
@@ -487,4 +775,6 @@
             status = "disabled";
         };
     };
+
+
 };
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 882f035..f52daff 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -382,6 +382,7 @@ CONFIG_RENESAS_MFIS_ECC=y
 #CONFIG_PHYLIB=y
 #CONFIG_MDIO_DEVICE=y
 CONFIG_PWM_RZV2M=y
+CONFIG_TIM_RZV2M=y
 CONFIG_E1000E=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 3bad7d6..e6c9e88 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -232,6 +232,8 @@ source "drivers/slimbus/Kconfig"
 
 source "drivers/udmabuf/Kconfig"
 
+source "drivers/hw_tim/Kconfig"
+
 source "drivers/interconnect/Kconfig"
 
 source "drivers/counter/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index fc0275c..838b111 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -187,6 +187,7 @@ obj-$(CONFIG_UNISYS_VISORBUS)	+= visorbus/
 obj-$(CONFIG_SIOX)		+= siox/
 obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_U_DMA_BUF)        += udmabuf/
+obj-y  				+= hw_tim/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
diff --git a/drivers/hw_tim/Kconfig b/drivers/hw_tim/Kconfig
new file mode 100644
index 0000000..8a8cd19
--- /dev/null
+++ b/drivers/hw_tim/Kconfig
@@ -0,0 +1,8 @@
+menu "RZ/V2M TIM drivers"
+
+config TIM_RZV2M
+       bool "Timer for the RZ/V2M"
+       help
+         RZ/V2M TIM drivers enable.
+
+endmenu
diff --git a/drivers/hw_tim/Makefile b/drivers/hw_tim/Makefile
new file mode 100644
index 0000000..d6ceee7
--- /dev/null
+++ b/drivers/hw_tim/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_TIM_RZV2M)              += tim_rzv2m.o
+
diff --git a/drivers/hw_tim/tim_rzv2m.c b/drivers/hw_tim/tim_rzv2m.c
new file mode 100644
index 0000000..a6539c1
--- /dev/null
+++ b/drivers/hw_tim/tim_rzv2m.c
@@ -0,0 +1,452 @@
+/*
+ * Driver for the Renesas RZ/V2M Timer unit(TIM)
+ *
+ * Copyright (C) 2020 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/tim_rzv2m.h>
+
+#define DRIVER_NAME "tim"
+
+static const unsigned int minor_base = 0;
+static const unsigned int minor_num  = 1;
+
+/* latch minor number */
+static int minor_n = 0;
+
+static unsigned int hw_tim_device_num = NULL;
+static struct class *tim_class = NULL;
+dev_t g_tim_dev = NULL;
+
+
+struct tim_priv {
+    struct cdev             tim_cdev;
+    struct platform_device  *pdev;
+    void __iomem            *base;
+    const char              *dev_name;
+    struct clk              *sys_clk;
+    struct tim_ioctl_if     ioctl_inf;
+    unsigned int            cmd_count;
+    struct completion hw_tim_wait_done;
+    bool                    isUsed;
+};
+
+//TIM register offfset
+#define TMD     0x00
+#define CMD     0x04
+#define TMCD    0x08
+#define INTCLR  0x10
+
+//CMD register field
+#define MAX_TIMCYS      0xFFFFFFFF /* Max value of 32 bits register is ffffffff */
+
+//TMCD register field
+#define TMCD_CS(div)        (div << 4)
+#define TMCD_INTMODE_LEVEL  BIT(2)
+#define TMCD_INTMODE_PLUSE  (0 << 2)
+#define TMCD_CE             BIT(1)
+#define TMCD_CAE            BIT(0)
+#define TMCD_MAXDIV_C0C1C2  (0x7)
+#define TMCD_TIM_START      (TMCD_CE | TMCD_CAE | TMCD_INTMODE_LEVEL)
+#define TMCD_TIM_STOP       (0x0)
+
+//INTCLR register field
+#define INTCLR_INTCLEAR     (0x1)
+
+
+
+/******************************************************************************
+Private global variables and functions
+******************************************************************************/
+static int rzv2m_tim_open(struct inode *inode, struct file *file);
+static int rzv2m_tim_close(struct inode *inode, struct file *file);
+static long rzv2m_tim_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+
+static int rzv2m_tim_start(struct tim_priv *priv);
+static void rzv2m_tim_stop(struct tim_priv *priv);
+static uint32_t rzv2m_tim_read_cnt(struct tim_priv *priv);
+
+static int rzv2m_calc_cycle_div(struct tim_priv *priv);
+static int rzv2m_calc_cnt(struct tim_priv *priv);
+static irqreturn_t irq_tim_interrupt(int irq, void *dev);
+
+static struct file_operations hw_tim_cdev_fops =
+{
+    .open           = rzv2m_tim_open,
+    .release        = rzv2m_tim_close,
+    .unlocked_ioctl = rzv2m_tim_ioctl,
+    .compat_ioctl   = rzv2m_tim_ioctl,
+};
+
+
+
+static int rzv2m_tim_start(struct tim_priv *priv)
+{
+    int ret = 0;
+    unsigned long time_left;
+
+    switch(priv->ioctl_inf.mode)
+    {
+    case IOCTL_START_FREERUN:
+
+        printk("IOCTL_START_FREERUN mode\n");
+        writel(MAX_TIMCYS, priv->base + CMD);
+        writel((TMCD_CS(priv->ioctl_inf.clk_div) | TMCD_TIM_START), priv->base + TMCD);
+
+        break;
+    case IOCTL_START_INTERRUPT:
+
+        printk("IOCTL_START_INTERRUPT mode\n");
+        reinit_completion(&priv->hw_tim_wait_done);
+        ret = rzv2m_calc_cycle_div(priv);
+        if( ret < 0 )
+            return ret;
+
+        time_left = wait_for_completion_timeout(&priv->hw_tim_wait_done, 60 * HZ );
+        if (!time_left)
+            return -ETIMEDOUT;
+
+        break;
+    default:
+        return -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static void rzv2m_tim_stop(struct tim_priv *priv)
+{
+    writel(TMCD_TIM_STOP, priv->base + TMCD);
+    return;
+}
+
+static int rzv2m_calc_cycle_div(struct tim_priv *priv)
+{
+    unsigned long clk_mhz = ((clk_get_rate(priv->sys_clk)/1000000)); /* MHz */
+    unsigned char div;
+    unsigned long   max_cnt;
+    unsigned long   usec = priv->ioctl_inf.tm_usec;
+    unsigned int    tim_cmd_val,tim_tmcd_val;
+
+    priv->ioctl_inf.clk_div = 0;
+
+    if (clk_mhz == 0)
+        return -EINVAL;
+
+    for (div = 0; div < TMCD_MAXDIV_C0C1C2; div++) {
+        max_cnt = ( (MAX_TIMCYS / clk_mhz) * (1 << (div+1) ));
+        tim_cmd_val = usec / ( (1 << (div+1) ) / clk_mhz );
+
+        if( max_cnt > usec )
+            break;
+    }
+
+    if( div >= TMCD_MAXDIV_C0C1C2 )
+    {
+        return -EINVAL;
+    }
+
+    priv->ioctl_inf.clk_div = div;
+    priv->cmd_count = tim_cmd_val;
+
+    tim_tmcd_val = TMCD_CS(priv->ioctl_inf.clk_div) | TMCD_TIM_START;
+
+    writel(tim_cmd_val,  priv->base + CMD);
+
+    writel(tim_tmcd_val, priv->base + TMCD);
+
+
+    return 0;
+}
+
+static uint32_t rzv2m_tim_read_cnt(struct tim_priv *priv)
+{
+    return readl( priv->base + TMD );
+}
+
+static int rzv2m_tim_open(struct inode *inode, struct file *file)
+{
+    struct tim_priv *priv;
+
+    priv = container_of(inode->i_cdev, struct tim_priv, tim_cdev);
+    if (priv  == NULL) {
+        printk(KERN_ERR "container_of\n");
+        return -EFAULT;
+    }
+
+    if( priv->isUsed )
+        return -EBUSY;
+    else
+    {
+        priv->isUsed = true; //set to used flag with corresponding channel.
+        file->private_data = priv;
+        //printk("%s:remap_addr[0x%x] \n",__func__,priv->base);
+    }
+    return 0;
+}
+
+static int rzv2m_tim_close(struct inode *inode, struct file *file)
+{
+
+    struct tim_priv *priv = file->private_data;
+
+    priv->isUsed = false;
+    return 0;
+}
+
+static long rzv2m_tim_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+
+    struct tim_priv *priv = filp->private_data;
+    int ioctl_ret = 0;
+
+    if( priv->isUsed )
+    {
+        switch (cmd) {
+        case IOCTL_TIM_START:
+            //printk("IOCTL_TIM_START\n");
+            if (raw_copy_from_user(&priv->ioctl_inf, (void __user *)arg, sizeof(struct tim_ioctl_if))) {
+                return -EFAULT;
+            }
+            //printk("%s:remap_addr[0x%x] \n",__func__,priv->base);
+            ioctl_ret = rzv2m_tim_start(priv);
+
+            break;
+
+        case IOCTL_TIM_STOP:
+            //printk("IOCTL_TIM_STOP\n");
+            rzv2m_tim_stop(priv);
+            break;
+
+        case IOCTL_GET_VALUES:
+            //printk("IOCTL_GET_VALUES\n");
+            priv->ioctl_inf.cnt_val = rzv2m_tim_read_cnt(priv);
+
+            if (raw_copy_to_user((void __user *)arg, &priv->ioctl_inf, sizeof(struct tim_ioctl_if))) {
+                ioctl_ret = (-EFAULT);
+            }
+            break;
+
+        default:
+            printk(KERN_WARNING "unsupported command %d\n", cmd);
+            ioctl_ret = (-EINVAL);
+            break;
+        }
+    }
+    else
+    {
+        ioctl_ret = -EBUSY;
+    }
+    return ioctl_ret;
+}
+
+static irqreturn_t irq_tim_interrupt(int irq, void *dev)
+{
+    struct tim_priv *priv = dev;
+    switch(priv->ioctl_inf.mode)
+    {
+    case IOCTL_START_FREERUN:
+        writel( INTCLR_INTCLEAR, priv->base + INTCLR);
+        break;
+    case IOCTL_START_INTERRUPT:
+        writel(TMCD_TIM_STOP, priv->base + TMCD);
+        writel( INTCLR_INTCLEAR, priv->base + INTCLR);
+        complete(&priv->hw_tim_wait_done);
+        break;
+    default:
+        break;
+    }
+    return IRQ_HANDLED;
+}
+
+
+/******************************************************************************
+* Function Name : tim_dev_probe
+* Description   :
+* Arguments     :
+* Return Value  :
+******************************************************************************/
+static int tim_dev_probe(struct platform_device *pdev)
+{
+    struct tim_priv *priv;
+    struct resource *res;
+    int irq,ret;
+    int cdev_err = 0;
+
+    hw_tim_device_num = MAJOR(g_tim_dev);
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct tim_priv), GFP_KERNEL);
+    if (!priv) {
+        dev_err(&pdev->dev, "cannot allocate private data\n");
+        return -ENOMEM;
+    }
+
+    init_completion(&priv->hw_tim_wait_done);
+
+    cdev_init(&priv->tim_cdev, &hw_tim_cdev_fops);
+
+    priv->tim_cdev.owner = THIS_MODULE;
+
+    cdev_err = cdev_add(&priv->tim_cdev,  MKDEV(hw_tim_device_num, minor_n), 1);
+    if (cdev_err != 0) {
+        printk(KERN_ERR  "cdev_add = %d\n", cdev_err);
+        return -1;
+    }
+
+
+    /* make /sys/class/mydevice/mydevice*  */
+    device_create(tim_class, NULL, MKDEV(hw_tim_device_num, minor_n), NULL, "hw_tim%d", minor_n);
+
+    platform_set_drvdata(pdev, priv);
+    priv->pdev = pdev;
+    /* Convert TIM base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources\n");
+        return -EINVAL;
+    }
+
+    priv->sys_clk = devm_clk_get(&pdev->dev, "timclk");
+    if (IS_ERR(priv->sys_clk)) {
+        dev_err(&pdev->dev, "failed to get system clock\n");
+        return PTR_ERR(priv->sys_clk);
+    }
+
+    //printk("%s:phy_addr[0x%x] \n",__func__,res->start);
+
+    priv->base = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res));
+    if (!priv->base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+
+
+    //printk("%s:remap_addr[0x%x] \n",__func__,priv->base);
+
+
+    /* Interrupt handler settings */
+    irq = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, irq, irq_tim_interrupt, 0, pdev->name, priv);
+    if (ret < 0) {
+        dev_err(&pdev->dev, "Failed to request IRQ\n");
+        return ret;
+    }
+
+    priv->isUsed = false;
+    minor_n = minor_n + 1;
+
+    printk("%s:probed\n",pdev->name);
+
+    return 0;
+
+}
+/******************************************************************************
+End of function tim_dev_probe
+******************************************************************************/
+
+
+/******************************************************************************
+* Function Name : tim_dev_probe
+* Description   :
+* Arguments     :
+* Return Value  :
+******************************************************************************/
+static int tim_dev_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+/******************************************************************************
+End of function tim_dev_probe
+******************************************************************************/
+
+/* For the device tree */
+static struct of_device_id tim_dev_of_match[] = {
+    { .compatible = "renesas,tim-rzv2m", },
+    { /* end of list */ },
+};
+
+/* For the device tree */
+static struct platform_driver tim_dev_driver = {
+    .driver = {
+        .name = DRIVER_NAME,
+        .of_match_table = tim_dev_of_match,
+    },
+    .probe      = tim_dev_probe,
+    .remove     = tim_dev_remove,
+};
+
+
+/******************************************************************************
+* Function Name : tim_device_init
+* Description   :
+* Arguments     :
+* Return Value  :
+******************************************************************************/
+static int tim_device_init(void)
+{
+    int alloc_ret = 0;
+
+    alloc_chrdev_region(&g_tim_dev, minor_base, minor_num, DRIVER_NAME);
+     if (alloc_ret != 0) {
+        printk(KERN_ERR  "alloc_chrdev_region = %d\n", alloc_ret);
+        return -1;
+    }
+
+    tim_class = class_create(THIS_MODULE, "hw_tim");
+    if (IS_ERR(tim_class)) {
+        printk(KERN_ERR  "class_create\n");
+        return -1;
+    }
+
+    return platform_driver_register(&tim_dev_driver);
+}
+/******************************************************************************
+End of function tim_device_init
+******************************************************************************/
+
+/******************************************************************************
+* Function Name : tim_device_exit
+* Description   :
+* Arguments     :
+* Return Value  :
+******************************************************************************/
+static void tim_device_exit(void)
+{
+    return 0;
+}
+/******************************************************************************
+End of function tim_device_exit
+******************************************************************************/
+
+module_init(tim_device_init);
+module_exit(tim_device_exit);
+MODULE_DEVICE_TABLE(of, tim_dev_of_match);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Renesas RZ/V2M TIM driver");
+MODULE_AUTHOR("Yoshifumi Ohtsuka <yoshifumi.ohtsuka.gx@bp.renesas.com>");
+
diff --git a/include/linux/tim_rzv2m.h b/include/linux/tim_rzv2m.h
new file mode 100644
index 0000000..84d97c5
--- /dev/null
+++ b/include/linux/tim_rzv2m.h
@@ -0,0 +1,54 @@
+/*
+ * Driver for the Renesas RZ/V2M Timer unit(TIM)
+ *
+ * Copyright (C) 2020 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef TIM_RZV2M_H_
+#define TIM_RZV2M_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct tim_ioctl_if {
+    int32_t     mode;
+    uint8_t     clk_div;
+    uint32_t    cnt_val;
+    uint64_t    tm_usec;
+};
+
+#define IOCTL_TIM_IO_TYPE   (55)
+#define IOCTL_TIM_START     _IOW (IOCTL_TIM_IO_TYPE, 1,struct tim_ioctl_if)
+#define IOCTL_TIM_STOP      _IO         (IOCTL_TIM_IO_TYPE, 2)
+#define IOCTL_GET_VALUES    _IOR (IOCTL_TIM_IO_TYPE, 3,struct tim_ioctl_if)
+
+enum rzv2m_start_mode
+{
+    IOCTL_START_FREERUN,
+    IOCTL_START_INTERRUPT
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TIM_RZV2M_H_ */
+
-- 
2.7.4

