From cf6f74f8bdcb236487d9f370e917c8bf6137abdf Mon Sep 17 00:00:00 2001
From: Hien Huynh <hien.huynh.px@renesas.com>
Date: Mon, 1 Mar 2021 11:56:08 +0700
Subject: [PATCH 087/135] drm: rcar-du: add support Renesas RZ/G2L MIPI DSI
 Encoder driver

This commit adds support MIPI DSI Encoder driver for Renesas RZ/G2L
SoC.

Signed-off-by: Hien Huynh <hien.huynh.px@renesas.com>
---
 drivers/gpu/drm/rcar-du/Kconfig               |   8 +
 drivers/gpu/drm/rcar-du/Makefile              |   1 +
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c        |  18 +
 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c      | 960 ++++++++++++++++++++++++++
 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.h      |  25 +
 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi_regs.h | 157 +++++
 6 files changed, 1169 insertions(+)
 create mode 100644 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
 create mode 100644 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.h
 create mode 100644 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi_regs.h

diff --git a/drivers/gpu/drm/rcar-du/Kconfig b/drivers/gpu/drm/rcar-du/Kconfig
index 075ce58..b4bb802 100644
--- a/drivers/gpu/drm/rcar-du/Kconfig
+++ b/drivers/gpu/drm/rcar-du/Kconfig
@@ -29,6 +29,14 @@ config DRM_RCAR_LVDS
 	help
 	  Enable support for the R-Car Display Unit embedded LVDS encoders.
 
+config DRM_RZG2L_MIPI_DSI
+	tristate "RZ/G2L MIPI DSI Encoder Support"
+	depends on DRM && DRM_BRIDGE && OF
+	select DRM_PANEL
+	select OF_FLATTREE
+	help
+	  Enable support for the RZG2L Display Unit embedded MIPI DSI encoders.
+
 config DRM_RCAR_VSP
 	bool "R-Car DU VSP Compositor Support" if ARM
 	default y if ARM64
diff --git a/drivers/gpu/drm/rcar-du/Makefile b/drivers/gpu/drm/rcar-du/Makefile
index 2a3b8d7..1de0bfc 100644
--- a/drivers/gpu/drm/rcar-du/Makefile
+++ b/drivers/gpu/drm/rcar-du/Makefile
@@ -17,6 +17,7 @@ rcar-du-drm-$(CONFIG_DRM_RCAR_VSP)	+= rcar_du_vsp.o
 obj-$(CONFIG_DRM_RCAR_DU)		+= rcar-du-drm.o
 obj-$(CONFIG_DRM_RCAR_DW_HDMI)		+= rcar_dw_hdmi.o
 obj-$(CONFIG_DRM_RCAR_LVDS)		+= rcar_lvds.o
+obj-$(CONFIG_DRM_RZG2L_MIPI_DSI)	+= rzg2l_mipi_dsi.o
 
 # 'remote-endpoint' is fixed up at run-time
 DTC_FLAGS_rcar_du_of_lvds_r8a7790 += -Wno-graph_endpoint
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index cec4b5c..a2a4bc7 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -32,6 +32,7 @@
 #include "rcar_du_regs.h"
 #include "rcar_du_vsp.h"
 #include "rcar_lvds.h"
+#include "rzg2l_mipi_dsi.h"
 
 static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)
 {
@@ -685,6 +686,15 @@ static void rcar_du_crtc_atomic_enable(struct drm_crtc *crtc,
 				     mode->clock * 1000);
 	}
 
+
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L) &&
+	    rstate->outputs == BIT(RCAR_DU_OUTPUT_MIPI_DSI0)) {
+		struct rcar_du_encoder *encoder =
+			rcdu->encoders[RCAR_DU_OUTPUT_MIPI_DSI0 + rcrtc->index];
+
+		rzg2l_mipi_dsi_clk_enable(encoder->base.bridge);
+	}
+
 	rcar_du_crtc_start(rcrtc);
 }
 
@@ -710,6 +720,14 @@ static void rcar_du_crtc_atomic_disable(struct drm_crtc *crtc,
 		rcar_lvds_clk_disable(encoder->base.bridge);
 	}
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_RZG2L) &&
+	    rstate->outputs == BIT(RCAR_DU_OUTPUT_MIPI_DSI0)) {
+		struct rcar_du_encoder *encoder =
+			rcdu->encoders[RCAR_DU_OUTPUT_MIPI_DSI0 + rcrtc->index];
+
+		rzg2l_mipi_dsi_clk_disable(encoder->base.bridge);
+	}
+
 	spin_lock_irq(&crtc->dev->event_lock);
 	if (crtc->state->event) {
 		drm_crtc_send_vblank_event(crtc, crtc->state->event);
diff --git a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
new file mode 100644
index 0000000..d22d59a
--- /dev/null
+++ b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
@@ -0,0 +1,960 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RZ/G2L MIPI DSI Encoder Driver
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <asm-generic/delay.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+
+#include "rzg2l_mipi_dsi_regs.h"
+#include "rzg2l_mipi_dsi.h"
+
+struct rzg2l_mipi_dsi {
+	struct device *dev;
+	void __iomem *link_mmio;
+	void __iomem *phy_mmio;
+
+	struct reset_control *rstc;
+
+	struct mipi_dsi_host host;
+
+	struct drm_bridge bridge;
+
+	struct drm_bridge *next_bridge;
+	struct drm_connector connector;
+	struct drm_panel *panel;
+
+	struct drm_display_mode display_mode;
+
+	struct clk *vclk;
+
+	enum mipi_dsi_pixel_format format;
+	unsigned int num_data_lanes;
+	unsigned int lanes;
+	unsigned long mode_flags;
+
+	unsigned long hsfreq;
+
+	bool hsclkmode;	/* 0 for non-continuous and 1 for continuous clock mode */
+};
+
+#define bridge_to_rzg2l_mipi_dsi(b) \
+	container_of(b, struct rzg2l_mipi_dsi, bridge)
+
+#define connector_to_rzg2l_mipi_dsi(c) \
+	container_of(c, struct rzg2l_mipi_dsi, connector)
+
+#define host_to_rzg2l_mipi_dsi(c) \
+	container_of(c, struct rzg2l_mipi_dsi, host)
+
+static void rzg2l_mipi_dsi_write(void __iomem *mem, u32 reg, u32 data)
+{
+	iowrite32(data, mem + reg);
+}
+
+static u32 rzg2l_mipi_dsi_read(void __iomem *mem, u32 reg)
+{
+	return ioread32(mem + reg);
+}
+
+static void rzg2l_mipi_dsi_clr(void __iomem *mem, u32 reg, u32 clr)
+{
+	rzg2l_mipi_dsi_write(mem, reg, rzg2l_mipi_dsi_read(mem, reg) & ~clr);
+}
+
+static void rzg2l_mipi_dsi_set(void __iomem *mem, u32 reg, u32 set)
+{
+	rzg2l_mipi_dsi_write(mem, reg, rzg2l_mipi_dsi_read(mem, reg) | set);
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware Setup
+ */
+
+static int rzg2l_mipi_dsi_startup(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	struct drm_display_mode *mode = &mipi_dsi->display_mode;
+	u32 rstsr;
+	u32 txsetr;
+	u32 clstptsetr;
+	u32 lptrnstsetr;
+	u8 max_num_lanes;
+	u32 clkkpt;
+	u32 clkbfht;
+	u32 clkstpt;
+	u32 golpbkt;
+	unsigned int timeout;
+	unsigned int bpp;
+	struct {
+		u32 tclk_miss;
+		u32 t_init;
+		u32 tclk_prepare;
+		u32 tclk_settle;
+		u32 tclk_trail;
+		u32 tclk_post;
+		u32 tclk_pre;
+		u32 tclk_zero;
+		u32 tlpx;
+		u32 ths_prepare;
+		u32 ths_settle;
+		u32 ths_exit;
+		u32 ths_trail;
+		u32 ths_zero;
+	} timings;
+	u32 dphyctrl0;
+	u32 dphytim0;
+	u32 dphytim1;
+	u32 dphytim2;
+	u32 dphytim3;
+
+	/* Relationship between hsclk and vclk must follow:
+	 * vclk * bpp = hsclk * 8 * lanes
+	 * where vclk: video clock (Hz)
+	 *       bpp: video pixel bit depth
+	 *       hsclk: DSI HS Byte clock frequency (Hz)
+	 *       lanes: number of data lanes
+	 *
+	 * hsclk(bit) = hsclk(byte) * 8
+         */
+
+	bpp = mipi_dsi_pixel_format_to_bpp(mipi_dsi->format);
+	mipi_dsi->hsfreq = (mode->clock * bpp * 8) / (8 * mipi_dsi->lanes);
+
+	/* Initializing DPHY before accessing LINK */
+
+	/* All DSI global operation timings are set with recommended setting */
+	if (mipi_dsi->hsfreq > 250000) {
+		timings.tclk_miss = 1;
+		timings.t_init = 79801;
+		timings.tclk_prepare = 8;
+		timings.tclk_settle = 9;
+		timings.tclk_trail = 7;
+		timings.tclk_post = 35;
+		timings.tclk_pre = 4;
+		timings.tclk_zero = 33;
+		timings.tlpx = 6;
+		timings.ths_prepare = 9;
+		timings.ths_settle = 9;
+		timings.ths_exit = 13;
+		timings.ths_trail = 9;
+		timings.ths_zero = 16;
+	} else {
+		timings.tclk_miss = 1;
+		timings.t_init = 79801;
+		timings.tclk_prepare = 8;
+		timings.tclk_settle = 9;
+		timings.tclk_trail = 10;
+		timings.tclk_post = 94;
+		timings.tclk_pre = 13;
+		timings.tclk_zero = 33;
+		timings.tlpx = 6;
+		timings.ths_prepare = 12;
+		timings.ths_settle = 9;
+		timings.ths_exit = 13;
+		timings.ths_trail = 17;
+		timings.ths_zero = 23;
+	}
+
+	dphytim0 = DSIDPHYTIM0_TCLK_MISS(timings.tclk_miss) |
+		   DSIDPHYTIM0_T_INIT(timings.t_init);
+	dphytim1 = DSIDPHYTIM1_THS_PREPARE(timings.ths_prepare) |
+		   DSIDPHYTIM1_TCLK_PREPARE(timings.tclk_prepare) |
+		   DSIDPHYTIM1_THS_SETTLE(timings.ths_settle) |
+		   DSIDPHYTIM1_TCLK_SETTLE(timings.tclk_settle);
+	dphytim2 = DSIDPHYTIM2_TCLK_TRAIL(timings.tclk_trail) |
+		   DSIDPHYTIM2_TCLK_POST(timings.tclk_post) |
+		   DSIDPHYTIM2_TCLK_PRE(timings.tclk_pre) |
+		   DSIDPHYTIM2_TCLK_ZERO(timings.tclk_zero);
+	dphytim3 = DSIDPHYTIM3_TLPX(timings.tlpx) |
+		   DSIDPHYTIM3_THS_EXIT(timings.ths_exit) |
+		   DSIDPHYTIM3_THS_TRAIL(timings.ths_trail) |
+		   DSIDPHYTIM3_THS_ZERO(timings.ths_zero);
+
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTIM0, dphytim0);
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTIM1, dphytim1);
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTIM2, dphytim2);
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTIM3, dphytim3);
+
+	/* Trimming signals is set with normal mode default code */
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTRIM0, 0x5A8BBBBB);
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYTRIM0,
+						 DSIDPHYCTRL1_TRIM_REGSEL);
+
+	dphyctrl0 = DSIDPHYCTRL0_CAL_EN_HSRX_OFS | DSIDPHYCTRL0_CMN_MASTER_EN |
+		    DSIDPHYCTRL0_RE_VDD_DETVCCQLV18 | DSIDPHYCTRL0_EN_BGR;
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYCTRL0, dphyctrl0);
+	udelay(20);
+	dphyctrl0 |= DSIDPHYCTRL0_EN_LDO1200;
+	rzg2l_mipi_dsi_write(mipi_dsi->phy_mmio, DSIDPHYCTRL0, dphyctrl0);
+	udelay(10);
+
+	/* TODO
+	 * Currently can not perform starting Software Reset Request because
+	 * vclk1 and hsclk is not on reset procedure.
+	 * Will support after confirming reset procedure carefully.
+	 *
+	 * Start Software Reset Request
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, RSTCR, RSTCR_SWRST);
+
+	for(timeout = 10; timeout > 0; timeout--) {
+		rstsr = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, RSTSR) & 0x1F;
+		if (rstsr == 0x1F)
+		break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		dev_err(mipi_dsi->dev, "failed to start software reset\n");
+		return -ETIMEDOUT;
+	}
+	 */
+
+	/* Check number of lanes capability */
+	max_num_lanes = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, TXSETR) >> 16;
+	max_num_lanes = (max_num_lanes & 0x3) + 1;
+	if (max_num_lanes < mipi_dsi->lanes) {
+		dev_err(mipi_dsi->dev, "DPHY can not support %d lanes\n",
+					mipi_dsi->lanes);
+		return -EINVAL;
+	}
+
+	/* Enable Data lanes and Clock lanes */
+	txsetr = TXSETR_DLEN | TXSETR_NUMLANEUSE(mipi_dsi->lanes - 1) | TXSETR_CLEN;
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, TXSETR, txsetr);
+
+	/* 
+	 * Global timings characteristic depends on high speed Clock Frequency
+	 * Currently MIPI DSI-IF just supports maximum FHD@60 with:
+	 * - videoclock = 148.5 (MHz)
+	 * - bpp: maximum 24bpp
+	 * - data lanes: maximum 4 lanes
+	 * Therefore maximum hsclk will be 891 Mbps.
+	 */
+
+	/* TODO
+	 * Clock lane Stop time parameter will be hard set in 3 ranges:
+	 * 1st range: 0 < hsclk <= 250 Mbps
+	 * 2nd range: 250 < hsclk <= 445.5 Mbps
+	 * 3rd range: hsclk > 445.5 Mbps
+	 * With 445.5 Mbps is hsclk at HD@60 or FHD@30 with 24bpp
+	 * and 4 data lanes.
+	 */
+
+	if (mipi_dsi->hsfreq > 445500) {
+		clkkpt = 12;
+		clkbfht = 15;
+		clkstpt = 48;
+		golpbkt = 75;
+	} else if (mipi_dsi->hsfreq > 250000){
+		clkkpt = 7;
+		clkbfht = 8;
+		clkstpt = 27;
+		golpbkt = 40;
+	} else {
+		clkkpt = 8;
+		clkbfht = 6;
+		clkstpt = 24;
+		golpbkt = 29;
+	}
+
+	clstptsetr = CLSTPTSETR_CLKKPT(clkkpt) | CLSTPTSETR_CLKBFHT(clkbfht) |
+		     CLSTPTSETR_CLKSTPT(clkstpt);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, CLSTPTSETR, clkkpt);
+
+	lptrnstsetr = LPTRNSTSETR_GOLPBKT(golpbkt);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, LPTRNSTSETR, lptrnstsetr);
+
+	/* TODO
+	 * Can not support Software Reset Procedure now.
+	 *
+	 * Force Tx Stop State
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, RSTCR, RSTCR_FCETXSTP |
+							 RSTCR_SWRST);
+
+
+	for(timeout = 10; timeout > 0; timeout--) {
+		rstsr = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, RSTSR);
+		if (!(rstsr & RSTSR_DL0DIR) && (((rstsr & RSTSR_DLSTPST) >> 8) == 0xf))
+			break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		dev_err(mipi_dsi->dev, "failed to force tx stop state\n");
+		return -ETIMEDOUT;
+	}
+
+	 * End Force Tx Stop State 
+	rzg2l_mipi_dsi_clr(mipi_dsi->link_mmio, RSTCR, RSTCR_FCETXSTP);
+
+	 * End Software Reset 
+	rzg2l_mipi_dsi_clr(mipi_dsi->link_mmio, RSTCR, RSTCR_SWRST);
+
+	for(timeout = 10; timeout > 0; timeout--) {
+		rstsr = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, RSTSR) & 0x1F;
+		if (!rstsr)
+			break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		dev_err(mipi_dsi->dev, "failed to finish software reset\n");
+		return -ETIMEDOUT;
+	}
+	 */
+
+	return 0;
+}
+
+static void rzg2l_mipi_dsi_set_display_timing(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	struct drm_display_mode *mode = &mipi_dsi->display_mode;
+	u32 vich1ppsetr;
+	u32 vich1vssetr;
+	u32 vich1vpsetr;
+	u32 vich1hssetr;
+	u32 vich1hpsetr;
+	int dsi_format;
+	u32 delay[2];
+
+	/* Configuration for Pixel Packet */
+	dsi_format = mipi_dsi_pixel_format_to_bpp(mipi_dsi->format);
+	switch (dsi_format) {
+	case 24:
+		vich1ppsetr = VICH1PPSETR_DT_RGB24;
+		break;
+	case 18:
+		vich1ppsetr = VICH1PPSETR_DT_RGB18;
+		break;
+	case 16:
+		vich1ppsetr = VICH1PPSETR_DT_RGB16;
+		break;
+	default:
+		dev_warn(mipi_dsi->dev, "unsupported format");
+		return;
+	}
+
+	if (mipi_dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		vich1ppsetr |= VICH1PPSETR_TXESYNC_PULSE;
+
+	if (mipi_dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		vich1ppsetr &= ~VICH1PPSETR_TXESYNC_PULSE;
+
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1PPSETR, vich1ppsetr);
+
+	/* Configuration for Video Parameters */
+	vich1vssetr = VICH1VSSETR_VACTIVE(mode->vdisplay) |
+		      VICH1VSSETR_VSA(mode->vsync_end - mode->vsync_start);
+	vich1vssetr |= (mode->flags & DRM_MODE_FLAG_PVSYNC) ?
+			VICH1VSSETR_VSPOL_HIGH : VICH1VSSETR_VSPOL_LOW;
+
+	vich1vpsetr = VICH1VPSETR_VFP(mode->vsync_start - mode->vdisplay) |
+		      VICH1VPSETR_VBP(mode->vtotal - mode->vsync_end);
+
+	vich1hssetr = VICH1HSSETR_HACTIVE(mode->hdisplay) |
+		      VICH1HSSETR_HSA(mode->hsync_end - mode->hsync_start);
+	vich1hssetr |= (mode->flags & DRM_MODE_FLAG_PHSYNC) ?
+			VICH1HSSETR_HSPOL_HIGH : VICH1HSSETR_HSPOL_LOW;
+
+	vich1hpsetr = VICH1HPSETR_HFP(mode->hsync_start - mode->hdisplay) |
+		      VICH1HPSETR_HBP(mode->htotal - mode->hsync_end);
+
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1VSSETR, vich1vssetr);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1VPSETR, vich1vpsetr);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1HSSETR, vich1hssetr);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1HPSETR, vich1hpsetr);
+
+	if (mipi_dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+		mipi_dsi->hsclkmode = 0;
+	else
+		mipi_dsi->hsclkmode = 1;
+
+	/* Configuration for Delay Value */
+	/* TODO
+	 * In HW manual, delay depends on many parameters with complex formula.
+	 * Therefore, hard set delay value based on 2 ranges of video clock.
+	 * 74.25MHz is videoclock of HD@60p or FHD@30p
+	 */
+
+	if (mode->clock > 74250) {
+		delay[0] = 231;
+		delay[1] = 216;
+	} else {
+		delay[0] = 220;
+		delay[1] = 212;
+	}
+
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1SET1R,
+			     VICH1SET1R_DLY(delay[mipi_dsi->hsclkmode]));
+}
+
+static int rzg2l_mipi_dsi_start_hs_clock(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	unsigned int timeout;
+	u32 status;
+	u32 hsclksetr;
+
+	/* In HW manual, we need to check stability of clock lane before
+	 * starting HS clock.
+	 * But it does not write how to check.
+	 * Therefore, we skip this check in current source and update if
+	 * any new information.
+	 */
+
+	/* Start HS clock */
+	hsclksetr = HSCLKSETR_HSCLKRUN_HS |
+		 (mipi_dsi->hsclkmode ? HSCLKSETR_HSCLKMODE_CONT :
+					HSCLKSETR_HSCLKMODE_NON_CONT);
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, HSCLKSETR, hsclksetr);
+
+	if (mipi_dsi->hsclkmode) {
+		for (timeout = 10; timeout > 0; --timeout) {
+			status = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, PLSR);
+			if (status & PLSR_CLLP2HS)
+				break;
+
+			usleep_range(1000, 2000);
+		}
+
+		if (!timeout) {
+			dev_err(mipi_dsi->dev, "failed to start HS clock\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	dev_dbg(mipi_dsi->dev, "Start High Speed Clock with %s clock mode",
+		mipi_dsi->hsclkmode ? "continuous" : "non-continuous");
+
+	return 0;
+}
+
+static int rzg2l_mipi_dsi_stop_hs_clock(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	unsigned int timeout;
+	u32 status;
+
+	/* Stop HS clock */
+	rzg2l_mipi_dsi_clr(mipi_dsi->link_mmio, HSCLKSETR,
+						HSCLKSETR_HSCLKRUN_HS);
+
+	if (mipi_dsi->hsclkmode) {
+		for (timeout = 10; timeout > 0; --timeout) {
+			status = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, PLSR);
+			if (status & PLSR_CLHS2LP)
+				break;
+
+			usleep_range(1000, 2000);
+		}
+
+		if (!timeout) {
+			dev_err(mipi_dsi->dev, "failed to stop HS clock\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+static int rzg2l_mipi_dsi_start_video(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	unsigned int timeout;
+	u32 status;
+	u32 vich1set0r;
+
+	/* Configuration for Blanking sequence and start video input*/
+	vich1set0r = VICH1SET0R_HFPNOLP | VICH1SET0R_HBPNOLP |
+		     VICH1SET0R_HSANOLP | VICH1SET0R_VSTART;
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1SET0R, vich1set0r);
+
+	for (timeout = 10; timeout > 0; --timeout) {
+		status = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, VICH1SR);
+		if (status & VICH1SR_VIRDY)
+			break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		dev_err(mipi_dsi->dev, "Failed to start video signal input\n");
+		return -ETIMEDOUT;
+	}
+
+	dev_dbg(mipi_dsi->dev, "Start video transferring");
+
+	return 0;
+}
+
+static int rzg2l_mipi_dsi_stop_video(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	unsigned int timeout;
+	u32 status;
+
+	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1SET0R, VICH1SET0R_VSTPAFT);
+
+	for (timeout = 10; timeout > 0; --timeout) {
+		status = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, VICH1SR);
+		if ((status & VICH1SR_STOP) && (!(status & VICH1SR_RUNNING)))
+			break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		goto err;
+	}
+
+	for (timeout = 10; timeout > 0; --timeout) {
+		status = rzg2l_mipi_dsi_read(mipi_dsi->link_mmio, LINKSR);
+		if (!(status & LINKSR_HSBUSY))
+			break;
+
+		usleep_range(1000, 2000);
+	}
+
+	if (!timeout) {
+		goto err;
+	}
+
+	return 0;
+err:
+	dev_err(mipi_dsi->dev, "Failed to stop video signal input\n");
+	return -ETIMEDOUT;
+}
+
+/* -----------------------------------------------------------------------------
+ * Connector & Panel
+ */
+
+static int rzg2l_mipi_dsi_connector_get_modes(struct drm_connector *connector)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi =
+					connector_to_rzg2l_mipi_dsi(connector);
+
+	return drm_panel_get_modes(mipi_dsi->panel);
+}
+
+static int
+rzg2l_mipi_dsi_connector_atomic_check(struct drm_connector *connector,
+				      struct drm_connector_state *state)
+{
+        struct rzg2l_mipi_dsi *mipi_dsi =
+					connector_to_rzg2l_mipi_dsi(connector);
+	const struct drm_display_mode *panel_mode;
+	struct drm_crtc_state *crtc_state;
+
+	if (!state->crtc)
+		return 0;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(mipi_dsi->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	panel_mode = list_first_entry(&connector->modes,
+				      struct drm_display_mode, head);
+
+	/* We're not allowed to modify the resolution. */
+	crtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	if (crtc_state->mode.hdisplay != panel_mode->hdisplay ||
+	    crtc_state->mode.vdisplay != panel_mode->vdisplay)
+		return -EINVAL;
+
+	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
+	drm_mode_copy(&crtc_state->adjusted_mode, panel_mode);
+
+	return 0;
+}
+
+static const struct drm_connector_helper_funcs rzg2l_mipi_dsi_conn_helper_funcs = {
+        .get_modes = rzg2l_mipi_dsi_connector_get_modes,
+        .atomic_check = rzg2l_mipi_dsi_connector_atomic_check,
+};
+
+static const struct drm_connector_funcs rzg2l_mipi_dsi_conn_funcs = {
+	.reset = drm_atomic_helper_connector_reset,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/* -----------------------------------------------------------------------------
+ * Bridge
+ */
+static int rzg2l_mipi_dsi_attach(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+	struct drm_connector *connector = &mipi_dsi->connector;
+	struct drm_encoder *encoder = bridge->encoder;
+	int ret;
+
+	if (mipi_dsi->next_bridge)
+		return drm_bridge_attach(bridge->encoder,
+					 mipi_dsi->next_bridge, bridge);
+
+	/* Otherwise if we have a panel, create a connector. */
+	if (!mipi_dsi->panel)
+		return 0;
+
+	ret = drm_connector_init(bridge->dev, connector,
+				 &rzg2l_mipi_dsi_conn_funcs,
+				 DRM_MODE_CONNECTOR_DSI);
+	if (ret < 0)
+		return ret;
+
+	drm_connector_helper_add(connector, &rzg2l_mipi_dsi_conn_helper_funcs);
+
+	ret = drm_connector_attach_encoder(connector, encoder);
+	if (ret < 0)
+		return ret;
+
+	return drm_panel_attach(mipi_dsi->panel, connector);
+}
+
+static void rzg2l_mipi_dsi_mode_set(struct drm_bridge *bridge,
+				    struct drm_display_mode *mode,
+				    struct drm_display_mode *adjusted_mode)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+
+	mipi_dsi->display_mode = *adjusted_mode;
+
+	clk_set_rate(mipi_dsi->vclk, adjusted_mode->clock * 1000);
+}
+
+static void rzg2l_mipi_dsi_enable(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+	int ret;
+
+	ret = rzg2l_mipi_dsi_startup(mipi_dsi);
+	if (ret < 0)
+		return;
+
+	rzg2l_mipi_dsi_set_display_timing(mipi_dsi);
+
+	ret = rzg2l_mipi_dsi_start_hs_clock(mipi_dsi);
+	if (ret < 0)
+		return;
+
+	ret = rzg2l_mipi_dsi_start_video(mipi_dsi);
+	if (ret < 0)
+		return;
+}
+
+static void rzg2l_mipi_dsi_disable(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+	int ret;
+
+	ret = rzg2l_mipi_dsi_stop_video(mipi_dsi);
+	if (ret < 0)
+		return;
+
+	ret = rzg2l_mipi_dsi_stop_hs_clock(mipi_dsi);
+	if (ret < 0)
+		return;
+}
+
+static enum drm_mode_status
+rzg2l_mipi_dsi_bridge_mode_valid(struct drm_bridge *bridge,
+				 const struct drm_display_mode *mode)
+{
+	if (mode->clock > 148500)
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static void rzg2l_mipi_dsi_detach(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+
+	if (mipi_dsi->panel)
+		drm_panel_detach(mipi_dsi->panel);
+}
+
+static const struct drm_bridge_funcs rzg2l_mipi_dsi_bridge_ops = {
+	.attach = rzg2l_mipi_dsi_attach,
+	.detach = rzg2l_mipi_dsi_detach,
+	.mode_set = rzg2l_mipi_dsi_mode_set,
+	.enable = rzg2l_mipi_dsi_enable,
+	.disable = rzg2l_mipi_dsi_disable,
+	.mode_valid = rzg2l_mipi_dsi_bridge_mode_valid,
+};
+
+/* -----------------------------------------------------------------------------
+ * Clock Setting
+ */
+
+int rzg2l_mipi_dsi_clk_enable(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+	int ret;
+
+	reset_control_deassert(mipi_dsi->rstc);
+
+	ret = clk_prepare_enable(mipi_dsi->vclk);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rzg2l_mipi_dsi_clk_enable);
+
+void rzg2l_mipi_dsi_clk_disable(struct drm_bridge *bridge)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = bridge_to_rzg2l_mipi_dsi(bridge);
+
+	clk_disable_unprepare(mipi_dsi->vclk);
+
+	reset_control_assert(mipi_dsi->rstc);
+}
+EXPORT_SYMBOL_GPL(rzg2l_mipi_dsi_clk_disable);
+
+/* -----------------------------------------------------------------------------
+ * Host setting
+ */
+
+static int rzg2l_mipi_dsi_host_attach(struct mipi_dsi_host *host,
+				      struct mipi_dsi_device *device)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = host_to_rzg2l_mipi_dsi(host);
+
+	if (device->lanes > mipi_dsi->num_data_lanes)
+		return -EINVAL;
+
+	mipi_dsi->lanes = device->lanes;
+	mipi_dsi->format = device->format;
+	mipi_dsi->mode_flags = device->mode_flags;
+
+	return 0;
+}
+
+static int rzg2l_mipi_dsi_host_detach(struct mipi_dsi_host *host,
+				      struct mipi_dsi_device *device)
+{
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops rzg2l_mipi_dsi_host_ops = {
+	.attach = rzg2l_mipi_dsi_host_attach,
+	.detach = rzg2l_mipi_dsi_host_detach,
+};
+
+/* -----------------------------------------------------------------------------
+ * Probe & Remove
+ */
+static int rzg2l_mipi_dsi_parse_dt(struct rzg2l_mipi_dsi *mipi_dsi)
+{
+	struct device_node *local_output = NULL;
+	struct device_node *remote_input = NULL;
+	struct device_node *remote = NULL;
+	struct device_node *node;
+	struct property *prop;
+	bool is_bridge = false;
+	int ret = 0;
+	int len, num_lanes;
+
+	local_output = of_graph_get_endpoint_by_regs(mipi_dsi->dev->of_node,
+						     1, 0);
+	if (!local_output) {
+		dev_dbg(mipi_dsi->dev, "unconnected port@1\n");
+		ret = -ENODEV;
+		goto done;
+	}
+
+	/*
+	 * Locate the connected entity and
+	 * infer its type from the number of endpoints.
+	 */
+	remote = of_graph_get_remote_port_parent(local_output);
+	if (!remote) {
+		dev_dbg(mipi_dsi->dev, "unconnected endpoint %pOF\n",
+		local_output);
+		ret = -ENODEV;
+		goto done;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_dbg(mipi_dsi->dev, "connected entity %pOF is disabled\n",
+		remote);
+		ret = -ENODEV;
+		goto done;
+	}
+
+	remote_input = of_graph_get_remote_endpoint(local_output);
+
+	for_each_endpoint_of_node(remote, node) {
+		if (node != remote_input) {
+			/*
+			 * The endpoint which is not input node must be bridge
+			 */
+			is_bridge = true;
+			of_node_put(node);
+			break;
+		}
+	}
+
+	if (is_bridge) {
+		mipi_dsi->next_bridge = of_drm_find_bridge(remote);
+		if (!mipi_dsi->next_bridge) {
+			ret = -EPROBE_DEFER;
+			goto done;
+		}
+	} else {
+		mipi_dsi->panel = of_drm_find_panel(remote);
+		if (IS_ERR(mipi_dsi->panel)) {
+			ret = PTR_ERR(mipi_dsi->panel);
+			goto done;
+		}
+	}
+
+	prop = of_find_property(local_output, "data-lanes", &len);
+	if (!prop) {
+		mipi_dsi->num_data_lanes = 4;
+		dev_dbg(mipi_dsi->dev, "Using default data lanes\n");
+		goto done;
+	}
+
+	num_lanes = len / sizeof(u32);
+	if (num_lanes < 1 || num_lanes > 4) {
+		dev_err(mipi_dsi->dev, "data lanes definition is not correct\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	mipi_dsi->num_data_lanes = num_lanes;
+
+done:
+	of_node_put(local_output);
+	of_node_put(remote_input);
+	of_node_put(remote);
+
+	return ret;
+}
+
+static struct clk *rzg2l_mipi_dsi_get_clk(struct rzg2l_mipi_dsi *mipi_dsi,
+					  const char *name)
+{
+	struct clk *clk;
+
+	clk = devm_clk_get(mipi_dsi->dev, name);
+	if (IS_ERR(clk)) {
+		dev_err(mipi_dsi->dev, "failed to get %s clock\n",
+			name ? name : "module");
+	}
+
+	return clk;
+}
+
+static int rzg2l_mipi_dsi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rzg2l_mipi_dsi *mipi_dsi;
+	struct resource *mem;
+	int ret;
+
+	mipi_dsi = devm_kzalloc(&pdev->dev, sizeof(*mipi_dsi), GFP_KERNEL);
+	if (mipi_dsi == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, mipi_dsi);
+	mipi_dsi->dev = dev;
+
+	ret = rzg2l_mipi_dsi_parse_dt(mipi_dsi);
+	if (ret < 0)
+		return ret;
+
+	/* Init bridge */
+	mipi_dsi->bridge.driver_private = mipi_dsi;
+	mipi_dsi->bridge.funcs = &rzg2l_mipi_dsi_bridge_ops;
+	mipi_dsi->bridge.of_node = pdev->dev.of_node;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mipi_dsi->link_mmio = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(mipi_dsi->link_mmio))
+		return PTR_ERR(mipi_dsi->link_mmio);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	mipi_dsi->phy_mmio = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(mipi_dsi->phy_mmio))
+		return PTR_ERR(mipi_dsi->phy_mmio);
+
+	mipi_dsi->vclk = rzg2l_mipi_dsi_get_clk(mipi_dsi, NULL);
+	if (IS_ERR(mipi_dsi->vclk))
+		return PTR_ERR(mipi_dsi->vclk);
+
+
+	mipi_dsi->rstc = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(mipi_dsi->rstc)) {
+		dev_err(&pdev->dev, "failed to get cpg reset\n");
+		return PTR_ERR(mipi_dsi->rstc);
+	}
+
+	/* Init host device */
+	mipi_dsi->host.dev = dev;
+	mipi_dsi->host.ops = &rzg2l_mipi_dsi_host_ops;
+	ret = mipi_dsi_host_register(&mipi_dsi->host);
+	if (ret < 0)
+		return ret;
+
+	drm_bridge_add(&mipi_dsi->bridge);
+
+	return 0;
+};
+
+static int rzg2l_mipi_dsi_remove(struct platform_device *pdev)
+{
+	struct rzg2l_mipi_dsi *mipi_dsi = platform_get_drvdata(pdev);
+
+	drm_bridge_remove(&mipi_dsi->bridge);
+
+	mipi_dsi_host_unregister(&mipi_dsi->host);
+
+	return 0;
+}
+
+static const struct of_device_id rzg2l_mipi_dsi_of_table[] = {
+	{ .compatible = "renesas,r9a07g044l-mipi-dsi" },
+	{ },
+};
+
+static struct platform_driver rzg2l_mipi_dsi_platform_driver = {
+	.probe	= rzg2l_mipi_dsi_probe,
+	.remove	= rzg2l_mipi_dsi_remove,
+	.driver	= {
+		.name = "rzg2l-mipi-dsi",
+		.of_match_table = rzg2l_mipi_dsi_of_table,
+	},
+};
+
+module_platform_driver(rzg2l_mipi_dsi_platform_driver);
+
+MODULE_AUTHOR("Hien Huynh <hien.huynh.px@renesas.com>");
+MODULE_DESCRIPTION("Renesas RZ/G2L MIPI DSI Encoder Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.h b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.h
new file mode 100644
index 0000000..cd69c3d
--- /dev/null
+++ b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.h
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RZ/G2L MIPI DSI Encoder Header
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ */
+
+#ifndef __RZG2L_MIPI_DSI_H__
+#define __RZG2L_MIPI_DSI_H__
+
+struct drm_bridge;
+
+#if IS_ENABLED(CONFIG_DRM_RZG2L_MIPI_DSI)
+int rzg2l_mipi_dsi_clk_enable(struct drm_bridge *bridge);
+void rzg2l_mipi_dsi_clk_disable(struct drm_bridge *bridge);
+#else
+static inline int rzg2l_mipi_dsi_clk_enable(struct drm_bridge *bridge)
+{
+	return -ENOSYS;
+}
+static inline void rzg2l_mipi_dsi_clk_disable(struct drm_bridge *bridge)
+{
+}
+#endif /* CONFIG_DRM_RZG2L_MIPI_DSI */
+#endif /* __RZG2L_MIPI_DSI_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi_regs.h b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi_regs.h
new file mode 100644
index 0000000..1a75df5
--- /dev/null
+++ b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi_regs.h
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * RZ/G2L MIPI DSI Interface Registers Definitions
+ *
+ * Copyright (C) 2020 Renesas Electronics Corporation
+ */
+
+#ifndef __RZG2L_MIPI_DSI_REGS_H__
+#define __RZG2L_MIPI_DSI_REGS_H__
+
+/* DPHY Registers */
+#define DSIDPHYCTRL0			0x00
+#define DSIDPHYCTRL0_CAL_EN_HSRX_OFS	(1 << 16)
+#define DSIDPHYCTRL0_CMN_MASTER_EN	(1 << 8)
+#define DSIDPHYCTRL0_RE_VDD_DETVCCQLV18	(1 << 2)
+#define DSIDPHYCTRL0_EN_LDO1200		(1 << 1)
+#define DSIDPHYCTRL0_EN_BGR		(1 << 0)
+
+#define DSIDPHYTIM0			0x04
+#define DSIDPHYTIM0_TCLK_MISS(x)	((x) << 24)
+#define DSIDPHYTIM0_T_INIT(x)		((x) << 0)
+
+#define DSIDPHYTIM1			0x08
+#define DSIDPHYTIM1_THS_PREPARE(x)	((x) << 24)
+#define DSIDPHYTIM1_TCLK_PREPARE(x)	((x) << 16)
+#define DSIDPHYTIM1_THS_SETTLE(x)	((x) << 8)
+#define DSIDPHYTIM1_TCLK_SETTLE(x)	((x) << 0)
+
+#define DSIDPHYTIM2			0x0C
+#define DSIDPHYTIM2_TCLK_TRAIL(x)	((x) << 24)
+#define DSIDPHYTIM2_TCLK_POST(x)	((x) << 16)
+#define DSIDPHYTIM2_TCLK_PRE(x)		((x) << 8)
+#define DSIDPHYTIM2_TCLK_ZERO(x)	((x) << 0)
+
+#define DSIDPHYTIM3			0x10
+#define DSIDPHYTIM3_TLPX(x)		((x) << 24)
+#define DSIDPHYTIM3_THS_EXIT(x)		((x) << 16)
+#define DSIDPHYTIM3_THS_TRAIL(x)	((x) << 8)
+#define DSIDPHYTIM3_THS_ZERO(x)		((x) << 0)
+
+#define DSIDPHYCTRL1			0x40
+#define DSIDPHYCTRL1_TRIM_REGSEL	(1 << 0)
+
+#define DSIDPHYTRIM0			0x44
+
+/* --------------------------------------------------------*/
+/* Link Registers */
+/* Link Status Register */
+#define LINKSR				0x10
+#define LINKSR_LPBUSY			(1 << 13)
+#define LINKSR_HSBUSY			(1 << 12)
+#define LINKSR_VICHRUN1			(1 << 8)
+#define LINKSR_SQCHRUN1			(1 << 4)
+#define LINKSR_SQCHRUN0			(1 << 0)
+
+/* Tx Set Register */
+#define TXSETR				0x100
+#define TXSETR_NUMLANECAP		(0x3 << 16)
+#define TXSETR_DLEN			(1 << 9)
+#define TXSETR_CLEN			(1 << 8)
+#define TXSETR_NUMLANEUSE(x)		(((x) & 0x3) << 0)
+
+/* HS Clock Set Register */
+#define HSCLKSETR			0x104
+#define HSCLKSETR_HSCLKMODE_CONT	(1 << 1)
+#define HSCLKSETR_HSCLKMODE_NON_CONT	(0 << 1)
+#define HSCLKSETR_HSCLKRUN_HS		(1 << 0)
+#define HSCLKSETR_HSCLKRUN_LP		(0 << 0)
+
+/* Reset Control Register */
+#define RSTCR				0x110
+#define RSTCR_SWRST			(1 << 0)
+#define RSTCR_FCETXSTP			(1 << 16)
+
+/* Reset Status Register */
+#define RSTSR				0x114
+#define RSTSR_DL0DIR			(1 << 15)
+#define RSTSR_DLSTPST			(0xf << 8)
+#define RSTSR_SWRSTV1			(1 << 4)
+#define RSTSR_SWRSTIB			(1 << 3)
+#define RSTSR_SWRSTAPB			(1 << 2)
+#define RSTSR_SWRSTLP			(1 << 1)
+#define RSTSR_SWRSTHS			(1 << 0)
+
+/* Clock Lane Stop Time Set Register */
+#define CLSTPTSETR			0x314
+#define CLSTPTSETR_CLKKPT(x)		((x) << 24)
+#define CLSTPTSETR_CLKBFHT(x)		((x) << 16)
+#define CLSTPTSETR_CLKSTPT(x)		((x) << 2)
+
+/* LP Transition Time Set Register */
+#define LPTRNSTSETR			0x318
+#define LPTRNSTSETR_GOLPBKT(x)		((x) << 0)
+
+/* Physical Lane Status Register */
+#define PLSR				0x320
+#define PLSR_CLHS2LP			(1 << 27)
+#define PLSR_CLLP2HS			(1 << 26)
+
+/* Video-Input Channel 1 Set 0 Register */
+#define VICH1SET0R			0x400
+#define VICH1SET0R_VSEN			(1 << 12)
+#define VICH1SET0R_HFPNOLP		(1 << 10)
+#define VICH1SET0R_HBPNOLP		(1 << 9)
+#define VICH1SET0R_HSANOLP		(1 << 8)
+#define VICH1SET0R_VSTPAFT		(1 << 1)
+#define VICH1SET0R_VSTART		(1 << 0)
+
+/* Video-Input Channel 1 Set 1 Register */
+#define VICH1SET1R			0x404
+#define VICH1SET1R_DLY(x)		(((x) & 0xfff) << 2)
+
+/* Video-Input Channel 1 Status Register */
+#define VICH1SR				0x410
+#define VICH1SR_VIRDY			(1 << 3)
+#define VICH1SR_RUNNING			(1 << 2)
+#define VICH1SR_STOP			(1 << 1)
+#define VICH1SR_START			(1 << 0)
+
+/* Video-Input Channel 1 Pixel Packet Set Register */
+#define VICH1PPSETR			0x420
+#define VICH1PPSETR_DT_RGB16		(0x0E << 16)
+#define VICH1PPSETR_DT_RGB18		(0x1E << 16)
+#define VICH1PPSETR_DT_RGB18_LS		(0x2E << 16)
+#define VICH1PPSETR_DT_RGB24		(0x3E << 16)
+#define VICH1PPSETR_DT_YCbCr16		(0x2C << 16)
+#define VICH1PPSETR_DT_YCbCr20_LS	(0x0C << 16)
+#define VICH1PPSETR_DT_YCbCr24		(0x1C << 16)
+#define VICH1PPSETR_TXESYNC_PULSE	(1 << 15)
+#define VICH1PPSETR_VC(x)		((x) << 22)
+
+/* Video-Input Channel 1 Vertical Size Set Register */
+#define VICH1VSSETR			0x428
+#define VICH1VSSETR_VACTIVE(x)		(((x) & 0x7fff) << 16)
+#define VICH1VSSETR_VSPOL_LOW		(1 << 15)
+#define VICH1VSSETR_VSPOL_HIGH		(0 << 15)
+#define VICH1VSSETR_VSA(x)		(((x) & 0xfff) << 0)
+
+/* Video-Input Channel 1 Vertical Porch Set Register */
+#define VICH1VPSETR			0x42C
+#define VICH1VPSETR_VFP(x)		(((x) & 0x1fff) << 16)
+#define VICH1VPSETR_VBP(x)		(((x) & 0x1fff) << 0)
+
+/* Video-Input Channel 1 Horizontal Size Set Register */
+#define VICH1HSSETR			0x430
+#define VICH1HSSETR_HACTIVE(x)		(((x) & 0x7fff) << 16)
+#define VICH1HSSETR_HSPOL_LOW		(1 << 15)
+#define VICH1HSSETR_HSPOL_HIGH		(0 << 15)
+#define VICH1HSSETR_HSA(x)		(((x) & 0xfff) << 0)
+
+/* Video-Input Channel 1 Horizontal Porch Set Register */
+#define VICH1HPSETR			0x434
+#define VICH1HPSETR_HFP(x)		(((x) & 0x1fff) << 16)
+#define VICH1HPSETR_HBP(x)		(((x) & 0x1fff) << 0)
+
+#endif /* __RZG2L_MIPI_DSI_REGS_H__ */
-- 
2.7.4

